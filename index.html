<!DOCTYPE html>
<html lang="bg">
<head>
  <meta charset="utf-8" />
  <title>RedBook Web Map — Animals & Plants/Fungi</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <!-- Leaflet -->
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
  <style>
    :root { --pad: 12px; --gap: 8px; --radius: 10px; }
    html, body { height: 100%; margin: 0; font-family: system-ui, Arial, sans-serif; }
    #map { position: absolute; inset: 0; }
    #sidebar {
      position: absolute; top: 10px; right: 10px; width: 340px; max-width: 94vw;
      max-height: calc(100% - 20px); overflow: auto; background: #fff; padding: var(--pad);
      border-radius: var(--radius); box-shadow: 0 6px 18px rgba(0,0,0,.25); z-index: 9999;
    }
    #sidebar h3 { margin: 0 0 var(--gap) 0; }
    .controls section { margin-bottom: 10px; }
    .controls label { display: block; margin: 4px 0; cursor: pointer; }
    .row { display: grid; grid-template-columns: 1fr 1fr; gap: var(--gap); }
    .row > * { width: 100%; }
    input[type="text"], select {
      width: 100%; padding: 8px; border: 1px solid #ccc; border-radius: 6px; font-size: 14px;
    }
    .checkline { display:flex; align-items:center; gap:8px; }
    .btnbar { display:flex; gap: var(--gap); margin: 6px 0 10px; }
    button {
      padding: 8px 10px; border-radius: 8px; border: 1px solid #ccc; background:#f6f6f6; cursor:pointer;
    }
    button:hover { background:#eee; }
    #count { margin: 6px 0; font-weight: 600; }
    #list { border-top: 1px solid #ddd; margin-top: 6px; }
    .feature-item { cursor:pointer; padding:8px 4px; border-bottom:1px solid #eee; }
    .feature-item:hover { background:#faf6e8; }
    .badge { display:inline-block; font-size: 11px; padding: 2px 6px; border-radius: 999px; background:#eef; border:1px solid #ccd; margin-left: 6px; }
    .legend { font-size: 12px; color:#666; }
    .muted { color:#666; }
    .hidden { display:none !important; }

    /* Leaflet point markers */
    .pt-marker {
      background: #1f78b4; width: 8px; height: 8px; border-radius: 50%; border: 1px solid white;
      box-shadow: 0 0 0 1px rgba(0,0,0,.15);
    }
    .pt-marker.highlight { background:#ff7f0e; }

    /* Polygon labels */
    .poly-label {
      background: rgba(255,255,255,0.75);
      padding: 2px 6px;
      border-radius: 8px;
      border: 1px solid #ccc;
      font-size: 12px;
      color: #333;
      box-shadow: 0 1px 3px rgba(0,0,0,.15);
    }

    /* По-изразено hover/selection на полигони */
    .leaflet-interactive.hovered {
      stroke-width: 3px !important;
      filter: brightness(1.2);
    }
  </style>
</head>
<body>
<div id="map"></div>

<div id="sidebar" aria-label="Sidebar">
  <h3>Червена книга — защитени видове</h3>
  <div class="controls" role="group" aria-label="Controls">
    <section>
      <strong>Полигонов слой</strong>
      <label><input type="radio" name="poly" value="morph" checked> morph_units</label>
      <label><input type="radio" name="poly" value="land"> landscape_zoning</label>
    </section>
    <section>
      <strong>Точков слой</strong>
      <label><input type="radio" name="points" value="animals" checked> Animals</label>
      <label><input type="radio" name="points" value="plants"> PlantsFungi</label>
    </section>
    <section>
      <input id="searchBox" type="text" placeholder="Търси в BG_NAME / LATIN_NAME…" aria-label="Search">
      <div class="row" style="margin-top:8px">
        <select id="ddSTATUS"><option value="">STATUS (всички)</option></select>
        <select id="ddFAMILY"><option value="">FAMILY (всички)</option></select>
      </div>
      <div class="row" id="rowTypeOrder" style="margin-top:8px">
        <select id="ddTYPE"><option value="">TYPE (всички)</option></select>
        <select id="ddORDER"><option value="">ORDER (всички)</option></select>
      </div>
      <div class="row" style="margin-top:8px">
        <select id="ddDISTRIBUTION"><option value="">DISTRIBUTION (всички)</option></select>
        <select id="ddZONE_IDS"><option value="">ZONE_IDS (Animals)</option></select>
      </div>
      <div class="row" style="margin-top:8px">
        <label class="checkline"><input type="checkbox" id="cbENDEMIC"> ENDEMIC</label>
        <label class="checkline"><input type="checkbox" id="cbRELICT"> RELICT</label>
      </div>
      <div style="margin-top:8px" id="extinctLine" class="checkline hidden">
        <input type="checkbox" id="cbEXTINCT"> <label for="cbEXTINCT">EXTINCT (Plants/Fungi)</label>
      </div>
      <div class="btnbar">
        <button id="btnClearFilters" title="Изчисти всички филтри">Изчисти филтрите</button>
        <button id="btnClearSel" title="Изчисти селекцията на полигон">Изчисти селекцията</button>
      </div>
      <div class="legend muted">Съвет: изберете полигон от активния полигонов слой.</div>
    </section>
  </div>
  <div id="count" class="muted">Изберете полигон.</div>
  <div id="list" role="list" aria-label="Result list"></div>
</div>

<!-- Leaflet & Turf -->
<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@turf/turf@6/turf.min.js"></script>
<script>
/* ---------- CONFIG: file paths ---------- */
const MORPH_GEOJSON_URL = 'data/morph_units.geojson';
const LANDSCAPE_GEOJSON_URL = 'data/landscape_zoning.geojson';
const ANIMALS_GEOJSON_URL = 'data/Animals.geojson';
const PLANTS_FUNGI_GEOJSON_URL = 'data/PlantsFungi.geojson';

/* ---------- MAP ---------- */
const map = L.map('map', { zoomControl: true }).setView([42.75, 25.3], 7);
L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', { maxZoom: 20, attribution: '&copy; OpenStreetMap' }).addTo(map);

/* ---------- STATE ---------- */
const state = {
  activePoly: 'morph',   // 'morph' | 'land'
  activePts:  'animals', // 'animals' | 'plants'
  selectedPolygonFeature: null,
  selectedPolygonLayer: null,
  explodedPoints: [],        // вътрешният набор (само точки вътре в полигона)
  filteredPoints: [],
  pointMarkerLayer: L.layerGroup().addTo(map),
  idCounter: 0,
  currentMarkers: [],
  currentMarkersByKey: new Map(),
  selectedSpeciesKey: null
};

/* ---------- UI elements ---------- */
const el = {
  search: document.getElementById('searchBox'),
  ddSTATUS: document.getElementById('ddSTATUS'),
  ddFAMILY: document.getElementById('ddFAMILY'),
  ddTYPE: document.getElementById('ddTYPE'),
  ddORDER: document.getElementById('ddORDER'),
  ddDISTRIBUTION: document.getElementById('ddDISTRIBUTION'),
  ddZONE_IDS: document.getElementById('ddZONE_IDS'),
  cbENDEMIC: document.getElementById('cbENDEMIC'),
  cbRELICT: document.getElementById('cbRELICT'),
  cbEXTINCT: document.getElementById('cbEXTINCT'),
  extinctLine: document.getElementById('extinctLine'),
  rowTypeOrder: document.getElementById('rowTypeOrder'),
  btnClearFilters: document.getElementById('btnClearFilters'),
  btnClearSel: document.getElementById('btnClearSel'),
  list: document.getElementById('list'),
  count: document.getElementById('count')
};

/* ---------- Layers ---------- */
const layers = { poly: {}, data: {} };

/* Label helper (NAME) */
function getPolyLabel(props = {}) { return props.NAME || ''; }

/* Load data and build layers */
Promise.all([
  fetch(MORPH_GEOJSON_URL).then(r=>r.json()),
  fetch(LANDSCAPE_GEOJSON_URL).then(r=>r.json()),
  fetch(ANIMALS_GEOJSON_URL).then(r=>r.json()),
  fetch(PLANTS_FUNGI_GEOJSON_URL).then(r=>r.json())
]).then(([morph, land, animals, plants]) => {
  layers.poly.morph = L.geoJSON(morph, {
    style: { color: '#B08D57', weight: 1, fillColor: '#F3E5AB', fillOpacity: 0.65 }, // бежово
    onEachFeature: (f, l) => {
      l.on({
        mouseover: e => { if (e?.target?._path) e.target._path.classList.add('hovered'); },
        mouseout:  e => { if (e?.target?._path) e.target._path.classList.remove('hovered'); },
        click:     () => onPolygonClick(f, l)
      });
      const lbl = getPolyLabel(f.properties);
      if (lbl) l.bindTooltip(lbl, { permanent: true, direction: 'center', className: 'poly-label' });
    }
  }).addTo(map);

  layers.poly.land = L.geoJSON(land, {
    style: { color: '#5A8F68', weight: 1, fillColor: '#CDE8B8', fillOpacity: 0.65 }, // зеленикаво
    onEachFeature: (f, l) => {
      l.on({
        mouseover: e => { if (e?.target?._path) e.target._path.classList.add('hovered'); },
        mouseout:  e => { if (e?.target?._path) e.target._path.classList.remove('hovered'); },
        click:     () => onPolygonClick(f, l)
      });
      const lbl = getPolyLabel(f.properties);
      if (lbl) l.bindTooltip(lbl, { permanent: true, direction: 'center', className: 'poly-label' });
    }
  }); // не е добавен по начало

  layers.data.animals = animals;
  layers.data.plants = plants;

  try { map.fitBounds(layers.poly.morph.getBounds(), { padding: [20,20] }); } catch(e){}

  wireControls();
  refreshFilterVisibility();
});

/* ---------- Polygon selection ---------- */
function onPolygonClick(feature, layer) {
  state.activePts = document.querySelector('input[name="points"]:checked').value;

  // изчистване стил на предишен полигон
  if (state.selectedPolygonLayer) try { state.selectedPolygonLayer.setStyle({weight:1}); } catch(e){}
  state.selectedPolygonLayer = layer;
  state.selectedPolygonFeature = feature;
  layer.setStyle({ weight: 4 }); // по-дебела рамка за селекция

  // авто-зуум към полигона
  try { map.fitBounds(layer.getBounds(), { padding: [20,20] }); } catch(e){}

  // Explode -> only inside
  const ptsFC = layers.data[state.activePts];
  const exploded = explodeMultiPoints(ptsFC);
  const inside = [];
  for (const pt of exploded) {
    if (turf.booleanPointInPolygon(pt, feature)) inside.push(pt);
  }
  state.explodedPoints = inside;

  populateFilterDropdowns(inside);
  applyFiltersAndRender();
}

/* ---------- MultiPoint -> Point[] ---------- */
function explodeMultiPoints(fc) {
  const out = [];
  for (const f of fc.features) {
    if (!f || !f.geometry) continue;
    if (f.geometry.type === 'MultiPoint') {
      for (const c of f.geometry.coordinates) {
        out.push({ type: 'Feature', geometry: { type: 'Point', coordinates: c }, properties: { ...f.properties } });
      }
    } else if (f.geometry.type === 'Point') {
      out.push(f);
    }
  }
  return out;
}

/* ---------- Filters ---------- */
function isTruthy(v) {
  if (v === null || v === undefined) return false;
  const s = String(v).trim().toLowerCase();
  return ['1','y','yes','true','да'].includes(s) || s.startsWith('y') || s.startsWith('д');
}
function uniqueSorted(values) {
  return [...new Set(values.filter(v => v !== null && v !== undefined && String(v).trim() !== ''))]
    .map(String).sort((a,b)=>a.localeCompare(b,'bg',{sensitivity:'base'}));
}
function populateFilterDropdowns(features) {
  const vals = { STATUS:[], FAMILY:[], TYPE:[], ORDER:[], DISTRIBUTION:[], ZONE_IDS:[] };
  for (const f of features) {
    const p = f.properties || {};
    if (p.STATUS!=null) vals.STATUS.push(p.STATUS);
    if (p.FAMILY!=null) vals.FAMILY.push(p.FAMILY);
    if (p.TYPE!=null) vals.TYPE.push(p.TYPE);
    if (p.ORDER!=null) vals.ORDER.push(p.ORDER);
    if (p.DISTRIBUTION!=null) vals.DISTRIBUTION.push(p.DISTRIBUTION);
    if (p.ZONE_IDS!=null) vals.ZONE_IDS.push(p.ZONE_IDS);
  }
  fillSelect(el.ddSTATUS, ['','...'].concat(uniqueSorted(vals.STATUS)), 'STATUS (всички)');
  fillSelect(el.ddFAMILY, ['','...'].concat(uniqueSorted(vals.FAMILY)), 'FAMILY (всички)');
  fillSelect(el.ddTYPE, ['','...'].concat(uniqueSorted(vals.TYPE)), 'TYPE (всички)');
  fillSelect(el.ddORDER, ['','...'].concat(uniqueSorted(vals.ORDER)), 'ORDER (всички)');
  fillSelect(el.ddDISTRIBUTION, ['','...'].concat(uniqueSorted(vals.DISTRIBUTION)), 'DISTRIBUTION (всички)');

  const zuniq = uniqueSorted(vals.ZONE_IDS);
  const useZone = (state.activePts === 'animals' && zuniq.length > 0 && zuniq.length <= 200);
  if (useZone) {
    fillSelect(el.ddZONE_IDS, ['','...'].concat(zuniq), 'ZONE_IDS (всички)');
    el.ddZONE_IDS.parentElement.classList.remove('hidden');
  } else {
    fillSelect(el.ddZONE_IDS, [''], 'ZONE_IDS (Animals)');
    el.ddZONE_IDS.parentElement.classList.add('hidden');
  }
}
function fillSelect(sel, values, firstLabel) {
  const current = sel.value;
  sel.innerHTML = '';
  const mk = (val, label) => {
    const opt = document.createElement('option');
    opt.value = val;
    opt.textContent = label ?? val;
    return opt;
  };
  sel.appendChild(mk('', firstLabel || '(всички)'));
  for (const v of values) {
    if (v === '') continue;
    sel.appendChild(mk(v, v));
  }
  if ([...sel.options].some(o=>o.value===current)) sel.value = current;
}

/* normalize string for case/diacritic-insensitive search */
function normalize(v) {
  if (v == null) return '';
  try { return String(v).toLowerCase().normalize('NFD').replace(/\p{Diacritic}/gu,''); }
  catch(e) { return String(v).toLowerCase(); }
}

/* Key for species (unique list) */
function speciesKey(props = {}) {
  const la = (props.LATIN_NAME || '').trim();
  const bg = (props.BG_NAME || '').trim();
  return `${la}||${bg}`;
}

/* Apply filters and render unique list + highlight groups */
function applyFiltersAndRender() {
  if (!state.selectedPolygonFeature) {
    el.count.textContent = 'Изберете полигон.';
    el.list.innerHTML = '';
    state.pointMarkerLayer.clearLayers();
    return;
  }
  const search = normalize(el.search.value);
  const sel = {
    STATUS: el.ddSTATUS.value,
    FAMILY: el.ddFAMILY.value,
    TYPE: el.ddTYPE.value,
    ORDER: el.ddORDER.value,
    DISTRIBUTION: el.ddDISTRIBUTION.value,
    ZONE_IDS: el.ddZONE_IDS.value,
    ENDEMIC: el.cbENDEMIC.checked,
    RELICT: el.cbRELICT.checked,
    EXTINCT: el.cbEXTINCT.checked
  };

  const arr = state.explodedPoints || [];
  const filtered = [];
  for (const f of arr) {
    const p = f.properties || {};
    const nameBG = normalize(p.BG_NAME);
    const nameLA = normalize(p.LATIN_NAME);
    if (search && !(nameBG.includes(search) || nameLA.includes(search))) continue;

    if (sel.STATUS && String(p.STATUS) !== sel.STATUS) continue;
    if (sel.FAMILY && String(p.FAMILY) !== sel.FAMILY) continue;

    if (state.activePts === 'animals') {
      if (sel.TYPE && String(p.TYPE) !== sel.TYPE) continue;
      if (sel.ORDER && String(p.ORDER) !== sel.ORDER) continue;
      if (sel.ZONE_IDS && String(p.ZONE_IDS) !== sel.ZONE_IDS) continue;
    }
    if (sel.DISTRIBUTION && String(p.DISTRIBUTION) !== sel.DISTRIBUTION) continue;
    if (sel.ENDEMIC && !isTruthy(p.ENDEMIC)) continue;
    if (sel.RELICT && !isTruthy(p.RELICT)) continue;
    if (state.activePts === 'plants' && sel.EXTINCT && !isTruthy(p.EXTINCT)) continue;

    filtered.push(f);
  }

  state.filteredPoints = filtered;
  renderListAndMarkers(filtered);
}

/* Render list (unique species) and all markers; click list -> highlight group */
function renderListAndMarkers(features) {
  const totalPoints = features.length;

  el.list.innerHTML = '';
  state.pointMarkerLayer.clearLayers();
  state.currentMarkers = [];
  state.currentMarkersByKey = new Map();

  if (!features.length) {
    el.count.textContent = 'Няма съвпадения.';
    return;
  }

  const bounds = [];
  for (const f of features) {
    const [lng, lat] = f.geometry.coordinates;
    const p = f.properties || {};
    const key = speciesKey(p);

    const marker = L.marker([lat, lng], {
      icon: L.divIcon({ className: 'pt-marker', iconSize: [10,10] }),
      title: (p.BG_NAME || p.LATIN_NAME || 'Point')
    }).addTo(state.pointMarkerLayer);

    marker.on('click', () => openPopupAt([lat, lng], p));
    marker._speciesKey = key;

    state.currentMarkers.push(marker);
    if (!state.currentMarkersByKey.has(key)) state.currentMarkersByKey.set(key, []);
    state.currentMarkersByKey.get(key).push(marker);

    bounds.push([lat, lng]);
  }

  const uniqueList = [];
  for (const [key, markers] of state.currentMarkersByKey.entries()) {
    const rep = features.find(ft => speciesKey(ft.properties) === key) || {};
    uniqueList.push({ key, count: markers.length, props: rep.properties || {} });
  }

  uniqueList.sort((a,b)=>{
    const an = (a.props.BG_NAME || a.props.LATIN_NAME || '').toLowerCase();
    const bn = (b.props.BG_NAME || b.props.LATIN_NAME || '').toLowerCase();
    return an.localeCompare(bn,'bg',{sensitivity:'base'});
  });

  for (const item of uniqueList) {
    const p = item.props;
    const div = document.createElement('div');
    div.className = 'feature-item';
    const main = `${p.BG_NAME || ''} ${p.LATIN_NAME ? `(${p.LATIN_NAME})` : ''}`;
    const badges = [
      p.ENDEMIC && isTruthy(p.ENDEMIC) ? '<span class="badge">ENDEMIC</span>' : '',
      p.RELICT  && isTruthy(p.RELICT)  ? '<span class="badge">RELICT</span>'  : '',
      (state.activePts==='plants' && isTruthy(p.EXTINCT)) ? '<span class="badge">EXTINCT</span>' : ''
    ].join(' ');
    div.innerHTML = `
      <div>${escapeHTML(main)} ${badges}</div>
      <div class="muted" style="font-size:12px">
        ${escapeHTML([p.STATUS, p.TYPE, p.FAMILY].filter(Boolean).join(' · '))}
        <span class="badge" title="Брой точки за този вид">${item.count}</span>
      </div>
    `;

    div.onclick = () => {
      state.selectedSpeciesKey = item.key;
      for (const m of state.currentMarkers) m._icon?.classList.remove('highlight');
      const group = state.currentMarkersByKey.get(item.key) || [];
      const gb = [];
      for (const m of group) {
        m._icon?.classList.add('highlight');
        gb.push(m.getLatLng());
      }
      if (gb.length) {
        const b = L.latLngBounds(gb);
        map.fitBounds(b.pad(0.25));
      }
    };

    el.list.appendChild(div);
  }

  el.count.textContent = `Намерени видове: ${uniqueList.length} (точки: ${totalPoints})`;

  if (bounds.length) {
    try { map.fitBounds(L.latLngBounds(bounds).pad(0.2)); } catch(e){}
  }
}

/* Popup table */
function openPopupAt(latlng, props) {
  const rows = [];
  const keysOrder = [
    'BG_NAME','LATIN_NAME','STATUS','TYPE','ORDER','FAMILY','DISTRIBUTION','ENDEMIC','RELICT','EXTINCT','ZONE_IDS'
  ];
  for (const k of keysOrder) {
    if (props[k] !== undefined) rows.push(`<tr><th style="text-align:left; padding-right:8px">${escapeHTML(k)}</th><td>${escapeHTML(props[k])}</td></tr>`);
  }
  for (const k of Object.keys(props)) {
    if (!keysOrder.includes(k)) rows.push(`<tr><th style="text-align:left; padding-right:8px">${escapeHTML(k)}</th><td>${escapeHTML(props[k])}</td></tr>`);
  }
  const html = `<table style="font-size:13px">${rows.join('')}</table>`;
  L.popup().setLatLng(latlng).setContent(html).openOn(map);
}

/* ---------- Controls / Events ---------- */
function wireControls() {
  document.querySelectorAll('input[name="poly"]').forEach(r => {
    r.addEventListener('change', () => {
      map.removeLayer(layers.poly[state.activePoly]);
      state.activePoly = r.value;
      map.addLayer(layers.poly[state.activePoly]);
      clearSelection();
      try { map.fitBounds(layers.poly[state.activePoly].getBounds(), { padding: [20,20] }); } catch(e){}
    });
  });

  document.querySelectorAll('input[name="points"]').forEach(r => {
    r.addEventListener('change', () => {
      state.activePts = r.value;
      refreshFilterVisibility();
      if (state.selectedPolygonFeature) {
        onPolygonClick(state.selectedPolygonFeature, state.selectedPolygonLayer);
      } else {
        clearSelection();
      }
    });
  });

  let t;
  el.search.addEventListener('input', () => {
    clearTimeout(t);
    t = setTimeout(applyFiltersAndRender, 300);
  });

  [el.ddSTATUS, el.ddFAMILY, el.ddTYPE, el.ddORDER, el.ddDISTRIBUTION, el.ddZONE_IDS,
   el.cbENDEMIC, el.cbRELICT, el.cbEXTINCT].forEach(ctrl => {
    ctrl.addEventListener('change', applyFiltersAndRender);
  });

  el.btnClearFilters.addEventListener('click', () => {
    el.search.value = '';
    [el.ddSTATUS, el.ddFAMILY, el.ddTYPE, el.ddORDER, el.ddDISTRIBUTION, el.ddZONE_IDS].forEach(sel => sel.value = '');
    el.cbENDEMIC.checked = false;
    el.cbRELICT.checked = false;
    el.cbEXTINCT.checked = false;
    applyFiltersAndRender();
  });

  el.btnClearSel.addEventListener('click', clearSelection);
}

function clearSelection() {
  if (state.selectedPolygonLayer) try { state.selectedPolygonLayer.setStyle({weight:1}); } catch(e){}
  state.selectedPolygonLayer = null;
  state.selectedPolygonFeature = null;
  state.explodedPoints = [];
  state.filteredPoints = [];
  state.pointMarkerLayer.clearLayers();
  state.selectedSpeciesKey = null;
  for (const m of state.currentMarkers) m._icon?.classList.remove('highlight');
  el.list.innerHTML = '';
  el.count.textContent = 'Изберете полигон.';
}

function refreshFilterVisibility() {
  const isAnimals = state.activePts === 'animals';
  el.rowTypeOrder.classList.toggle('hidden', !isAnimals);
  el.extinctLine.classList.toggle('hidden', isAnimals);
}

/* ---------- Utils ---------- */
function escapeHTML(v) {
  if (v===null || v===undefined) return '';
  return String(v)
   .replaceAll('&','&amp;')
   .replaceAll('<','&lt;')
   .replaceAll('>','&gt;')
   .replaceAll('"','&quot;')
   .replaceAll("'",'&#39;');
}
</script>
</body>
</html>
