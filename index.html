<!DOCTYPE html>
<html lang="bg">
<head>
  <meta charset="utf-8" />
  <title>RedBook Web Map — Animals & Plants/Fungi</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <!-- Leaflet -->
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
  <style>
    :root{
      --pad:12px; --gap:8px; --radius:10px;

      /* Badge / chip styling */
      --chip-radius: 999px;
      --chip-px: 8px; --chip-py: 3px;

      /* Endemic / Relict */
      --gold-bg:#F7E9B5; --gold-bd:#E3C676; --gold-tx:#7A5C00;
      --purp-bg:#E8D9F7; --purp-bd:#C3ACE6; --purp-tx:#4B2E83;

      /* Status scale (soft) */
      --st-lc-bg:#E6F4EA; --st-lc-bd:#B7E1C1; --st-lc-tx:#1B5E20; /* LC */
      --st-nt-bg:#FFF8E1; --st-nt-bd:#FFE39B; --st-nt-tx:#8C6D1F; /* NT */
      --st-vu-bg:#FFF3CD; --st-vu-bd:#FFE08A; --st-vu-tx:#7A5E00; /* VU */
      --st-en-bg:#FFE0B2; --st-en-bd:#FFCC80; --st-en-tx:#8B3E00; /* EN */
      --st-cr-bg:#FFCDD2; --st-cr-bd:#F5A3AB; --st-cr-tx:#B71C1C; /* CR */
      --st-dd-bg:#E3F2FD; --st-dd-bd:#BBDEFB; --st-dd-tx:#0D47A1; /* DD */
      --st-ex-bg:#111111; --st-ex-bd:#000000; --st-ex-tx:#FFFFFF; /* EX */
    }

    /* Без хоризонтален скрол на страницата */
    *, *::before, *::after { box-sizing: border-box; }
    html, body{
      height:100%; margin:0; font-family:system-ui, Arial, sans-serif;
      overflow-x: hidden;
    }

    #map { position:absolute; inset:0; }

    /* Фиксиран панел; скрол само в списъка */
    #sidebar{
      position:absolute; top:10px; right:10px;
      width:500px; max-width:calc(100vw - 20px);
      height:94vh;                           /* леко над OSM надписа */
      background:#fff; padding:var(--pad);
      border-radius:var(--radius); box-shadow:0 6px 18px rgba(0,0,0,.25);
      z-index:9999;

      display:flex; flex-direction:column;
      overflow:hidden;                        /* без скрол на панела */
    }
    #sidebar h3{
      margin:0 0 var(--gap) 0;
      text-align:center;
    }

    .controls{ flex:0 0 auto; overflow:hidden; }
    .controls section{ margin-bottom:10px; }
    .controls label{ display:block; margin:4px 0; cursor:pointer; }

    #count{ margin:6px 0; font-weight:600; flex:0 0 auto; }

    /* Списъкът – вертикален скрол тук */
    #list{
      border-top:1px solid #ddd; margin-top:6px;
      flex:1 1 auto; min-height:0;
      overflow-y:auto; overflow-x:hidden;
    }

    /* Гридове без преливане */
    .row{
      display:grid;
      grid-template-columns: minmax(0,1fr) minmax(0,1fr);
      gap:var(--gap);
    }
    .row > *{ min-width:0; }

    input[type="text"], select{
      width:100%; max-width:100%; display:block;
      padding:8px; border:1px solid #ccc; border-radius:6px; font-size:14px;
      min-width:0;
    }
    #sidebar select{ text-overflow:ellipsis; white-space:nowrap; overflow:hidden; }

    label{ overflow-wrap:anywhere; word-break:break-word; }

    .checkline{ display:flex; align-items:center; gap:8px; }

    /* Бутони – центрирани и равномерни */
    .btnbar{
      display:flex; justify-content:space-evenly; align-items:center;
      gap:var(--gap); margin:6px 0 10px;
    }
    .btnbar button{
      padding:8px 10px; border-radius:8px; border:1px solid #ccc;
      background:#f6f6f6; cursor:pointer; min-width:150px;
    }
    .btnbar button:hover{ background:#eee; }

    .legend{ font-size:12px; color:#666; }
    .muted{ color:#666; }
    .hidden{ display:none !important; }

    /* Маркери */
    .pt-marker{
      background:#1f78b4; width:8px; height:8px; border-radius:50%; border:1px solid #fff;
      box-shadow:0 0 0 1px rgba(0,0,0,.15);
    }
    .pt-marker.highlight{ background:#ff7f0e; }

    /* Етикети на полигони */
    .poly-label{
      background:rgba(255,255,255,0.75);
      padding:2px 6px; border-radius:8px; border:1px solid #ccc;
      font-size:12px; color:#333; box-shadow:0 1px 3px rgba(0,0,0,.15);
    }

    .leaflet-interactive.hovered{ stroke-width:3px !important; filter:brightness(1.2); }

    /* ---------- НОВ UI за ред в списъка ---------- */
    .feature-item{
      display:grid;
      grid-template-columns: 88px 1fr 120px;   /* релса за баджове | текст | бутон */
      align-items:center;
      gap:10px;
      min-height:64px;
      padding:10px 8px;
      border-bottom:1px solid #eee;
      cursor:pointer;
    }
    .feature-item:hover{ background:#faf6e8; }

    /* Колона 1: релса за баджове */
    .feature-badges{
      display:flex; gap:6px; flex-wrap:wrap; align-items:center; justify-content:flex-start;
      min-height:24px;
    }

    /* Колона 2: имена + мета */
    .feature-names{ display:flex; flex-direction:column; gap:2px; min-width:0; }
    .feature-names .name-bg{
      font-weight:700; line-height:1.2; overflow:hidden; text-overflow:ellipsis; white-space:nowrap;
    }
    .feature-names .name-la{
      font-style:italic; font-size:0.875rem; opacity:.85; line-height:1.1;
      overflow:hidden; text-overflow:ellipsis; white-space:nowrap;
    }
    .feature-meta{
      margin-top:4px; font-size:12px; color:#666; display:flex; gap:8px; align-items:center; flex-wrap:wrap;
    }

    /* Чипове / баджове */
    .chip{
      display:inline-flex; align-items:center; gap:6px;
      padding: var(--chip-py) var(--chip-px);
      border-radius: var(--chip-radius);
      border:1px solid transparent;
      font-size:11px; line-height:1;
      white-space:nowrap;
    }
    .chip--endemic{ background:var(--gold-bg); border-color:var(--gold-bd); color:var(--gold-tx); }
    .chip--relict{  background:var(--purp-bg); border-color:var(--purp-bd); color:var(--purp-tx); }

    /* Статус чипове */
    .chip--st{ font-weight:600; }
    .chip--st.lc{ background:var(--st-lc-bg); border-color:var(--st-lc-bd); color:var(--st-lc-tx); }
    .chip--st.nt{ background:var(--st-nt-bg); border-color:var(--st-nt-bd); color:var(--st-nt-tx); }
    .chip--st.vu{ background:var(--st-vu-bg); border-color:var(--st-vu-bd); color:var(--st-vu-tx); }
    .chip--st.en{ background:var(--st-en-bg); border-color:var(--st-en-bd); color:var(--st-en-tx); }
    .chip--st.cr{ background:var(--st-cr-bg); border-color:var(--st-cr-bd); color:var(--st-cr-tx); }
    .chip--st.dd{ background:var(--st-dd-bg); border-color:var(--st-dd-bd); color:var(--st-dd-tx); }
    .chip--st.ex{ background:var(--st-ex-bg); border-color:var(--st-ex-bd); color:var(--st-ex-tx); }

    /* Десният бутон */
    .link-btn{
      width:120px; text-align:center; padding:6px 8px; font-size:12px;
      border-radius:6px; border:1px solid #ccc; background:#f4f6ff; cursor:pointer; white-space:nowrap;
    }
    .link-btn:hover{ background:#e9edff; }
    .link-btn:disabled{ opacity:.5; cursor:not-allowed; }
  </style>
</head>
<body>
  <div id="map"></div>

  <div id="sidebar" aria-label="Sidebar">
    <h3>Червената книга на България - ГИС платформа</h3>
    <div class="controls" role="group" aria-label="Controls">
      <section>
        <strong>Основа</strong>
        <label><input type="radio" name="poly" value="morph" checked> Геоморфоложки структури</label>
        <label><input type="radio" name="poly" value="land"> Ландшафтно райониране</label>
      </section>
      <section>
        <strong>Книги</strong>
        <label><input type="radio" name="points" value="plants"> Том I. Растения и гъби</label>
        <label><input type="radio" name="points" value="animals" checked> Том II. Животни</label>
      </section>
      <section>
        <input id="searchBox" type="text" placeholder="Търси в BG_NAME / LATIN_NAME…" aria-label="Search">
        <div class="row" style="margin-top:8px">
          <select id="ddSTATUS"><option value="">Природозащитен статус (всички)</option></select>
          <select id="ddFAMILY"><option value="">Семейство (всички)</option></select>
        </div>
        <div class="row" id="rowTypeOrder" style="margin-top:8px">
          <select id="ddTYPE"><option value="">Тип (всички)</option></select>
          <select id="ddORDER"><option value="">Разред (всички)</option></select>
        </div>
        <div class="row" style="margin-top:8px">
          <label class="checkline"><input type="checkbox" id="cbENDEMIC"> Ендемит</label>
          <label class="checkline"><input type="checkbox" id="cbRELICT"> Реликт</label>
        </div>
        <div class="btnbar">
          <button id="btnClearFilters" title="Изчисти всички филтри">Изчисти филтрите</button>
          <button id="btnClearSel" title="Изчисти селекцията на полигон">Изчисти селекцията</button>
        </div>
        <div class="legend muted">Съвет: напишете търсене или изберете полигон/филтри.</div>
      </section>
    </div>
    <div id="count" class="muted">Въведете търсене или изберете филтър.</div>
    <div id="list" role="list" aria-label="Result list"></div>
  </div>

  <!-- Leaflet & Turf -->
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@turf/turf@6/turf.min.js"></script>
  <script>
    /* ---------- CONFIG: file paths ---------- */
    const MORPH_GEOJSON_URL = 'data/morph_units.geojson';
    const LANDSCAPE_GEOJSON_URL = 'data/landscape_zoning.geojson';
    const ANIMALS_GEOJSON_URL = 'data/Animals.geojson';
    const PLANTS_FUNGI_GEOJSON_URL = 'data/PlantsFungi.geojson';

    /* ---------- MAP ---------- */
    const map = L.map('map', { zoomControl: true }).setView([42.75, 25.3], 7);
    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', { maxZoom: 20, attribution: '&copy; OpenStreetMap' }).addTo(map);

    /* ---------- STATE ---------- */
    const state = {
      activePoly: 'morph',   // 'morph' | 'land'
      activePts:  'animals', // 'animals' | 'plants'
      selectedPolygonFeature: null,
      selectedPolygonLayer: null,
      explodedPoints: [],
      filteredPoints: [],
      pointMarkerLayer: L.layerGroup().addTo(map),
      currentMarkers: [],
      currentMarkersByKey: new Map(),
      selectedSpeciesKey: null
    };

    /* ---------- UI elements ---------- */
    const el = {
      search: document.getElementById('searchBox'),
      ddSTATUS: document.getElementById('ddSTATUS'),
      ddFAMILY: document.getElementById('ddFAMILY'),
      ddTYPE: document.getElementById('ddTYPE'),
      ddORDER: document.getElementById('ddORDER'),
      cbENDEMIC: document.getElementById('cbENDEMIC'),
      cbRELICT: document.getElementById('cbRELICT'),
      rowTypeOrder: document.getElementById('rowTypeOrder'),
      btnClearFilters: document.getElementById('btnClearFilters'),
      btnClearSel: document.getElementById('btnClearSel'),
      list: document.getElementById('list'),
      count: document.getElementById('count')
    };

    /* ---------- Layers ---------- */
    const layers = { poly: {}, data: {} };

    const BASE_STYLES = {
      morph: { color: '#B08D57', weight: 1, fillColor: '#F3E5AB', fillOpacity: 0.65 },
      land:  { color: '#5A8F68', weight: 1, fillColor: '#CDE8B8', fillOpacity: 0.65 }
    };
    const SELECTED_STYLES = {
      morph: { color: '#B08D57', weight: 4, fillColor: '#FFF4C9', fillOpacity: 0.8 },
      land:  { color: '#5A8F68', weight: 4, fillColor: '#E9F6D8', fillOpacity: 0.8 }
    };

    function getPolyLabel(props = {}) { return props.NAME || ''; }

    /* Load data and build layers */
    Promise.all([
      fetch(MORPH_GEOJSON_URL).then(r => r.json()),
      fetch(LANDSCAPE_GEOJSON_URL).then(r => r.json()),
      fetch(ANIMALS_GEOJSON_URL).then(r => r.json()),
      fetch(PLANTS_FUNGI_GEOJSON_URL).then(r => r.json())
    ]).then(([morph, land, animals, plants]) => {
      layers.poly.morph = L.geoJSON(morph, {
        style: BASE_STYLES.morph,
        onEachFeature: (f, l) => {
          l.on({
            mouseover: e => { if (e?.target?._path) e.target._path.classList.add('hovered'); },
            mouseout:  e => { if (e?.target?._path) e.target._path.classList.remove('hovered'); },
            click:     () => onPolygonClick(f, l)
          });
          const lbl = getPolyLabel(f.properties);
          if (lbl) l.bindTooltip(lbl, { permanent: true, direction: 'center', className: 'poly-label' });
        }
      }).addTo(map);

      layers.poly.land = L.geoJSON(land, {
        style: BASE_STYLES.land,
        onEachFeature: (f, l) => {
          l.on({
            mouseover: e => { if (e?.target?._path) e.target._path.classList.add('hovered'); },
            mouseout:  e => { if (e?.target?._path) e.target._path.classList.remove('hovered'); },
            click:     () => onPolygonClick(f, l)
          });
          const lbl = getPolyLabel(f.properties);
          if (lbl) l.bindTooltip(lbl, { permanent: true, direction: 'center', className: 'poly-label' });
        }
      });

      layers.data.animals = animals;
      layers.data.plants  = plants;

      setGlobalExplodedFromActive();
      populateFilterDropdowns(state.explodedPoints);

      /* Начален fit по morph с асиметричен десен padding */
      fitToMorphBG();

      wireControls();
      refreshFilterVisibility();
    });

    /* ---- Лек авто-зуум само по морфоложкия слой + асиметричен десен padding ---- */
    function fitToMorphBG() {
      try {
        const bounds = layers.poly.morph?.getBounds();
        if (!bounds || !bounds.isValid()) return;
        map.invalidateSize();

        const sidebar = document.getElementById('sidebar');
        const mapEl = document.getElementById('map');
        const sidebarW = sidebar ? sidebar.getBoundingClientRect().width : 0;
        const mapW = mapEl ? mapEl.clientWidth : window.innerWidth;
        const rightPad = Math.min(Math.round(sidebarW), Math.round(mapW * 0.45));

        map.fitBounds(bounds, {
          paddingTopLeft: [30, 30],
          paddingBottomRight: [30 + rightPad, 30],
          maxZoom: 8
        });
      } catch (e) { console.warn('Неуспешно начално побиране:', e); }
    }

    (function () {
      let t;
      window.addEventListener('resize', () => {
        clearTimeout(t);
        t = setTimeout(() => fitToMorphBG(), 200);
      });
    })();

    /* ---------- Helpers ---------- */
    function explodeMultiPoints(fc) {
      const out = [];
      for (const f of fc.features) {
        if (!f || !f.geometry) continue;
        if (f.geometry.type === 'MultiPoint') {
          for (const c of f.geometry.coordinates) {
            out.push({ type: 'Feature', geometry: { type: 'Point', coordinates: c }, properties: { ...f.properties } });
          }
        } else if (f.geometry.type === 'Point') {
          out.push(f);
        }
      }
      return out;
    }

    function setGlobalExplodedFromActive() {
      const fc = layers.data[state.activePts];
      state.explodedPoints = explodeMultiPoints(fc);
    }

    function onPolygonClick(feature, layer) {
      state.activePts = document.querySelector('input[name="points"]:checked').value;

      if (state.selectedPolygonLayer) {
        try { state.selectedPolygonLayer.setStyle(BASE_STYLES[state.activePoly]); } catch(e){}
      }
      state.selectedPolygonLayer = layer;
      state.selectedPolygonFeature = feature;
      layer.setStyle(SELECTED_STYLES[state.activePoly]);

      const exploded = explodeMultiPoints(layers.data[state.activePts]);
      const inside = [];
      for (const pt of exploded) if (turf.booleanPointInPolygon(pt, feature)) inside.push(pt);
      state.explodedPoints = inside;

      populateFilterDropdowns(inside);
      applyFiltersAndRender();
    }

    function uniqueSorted(values) {
      return [...new Set(values.filter(v => v !== null && v !== undefined && String(v).trim() !== ''))]
        .map(String).sort((a,b)=>a.localeCompare(b,'bg',{sensitivity:'base'}));
    }

    function fillSelect(sel, values, firstLabel) {
      const current = sel.value;
      sel.innerHTML = '';
      const mk = (val, label) => {
        const opt = document.createElement('option');
        opt.value = val;
        opt.textContent = label ?? val;
        return opt;
      };
      sel.appendChild(mk('', firstLabel || '(всички)'));
      for (const v of values) { if (v !== '') sel.appendChild(mk(v, v)); }
      if ([...sel.options].some(o=>o.value===current)) sel.value = current;
    }

    function populateFilterDropdowns(features) {
      const vals = { STATUS:[], FAMILY:[], TYPE:[], ORDER:[] };
      for (const f of features) {
        const p = f.properties || {};
        if (p.STATUS!=null) vals.STATUS.push(p.STATUS);
        if (p.FAMILY!=null) vals.FAMILY.push(p.FAMILY);
        if (p.TYPE!=null)   vals.TYPE.push(p.TYPE);
        if (p.ORDER!=null)  vals.ORDER.push(p.ORDER);
      }
      fillSelect(el.ddSTATUS, uniqueSorted(vals.STATUS), 'Природозащитен статус (всички)');
      fillSelect(el.ddFAMILY, uniqueSorted(vals.FAMILY), 'Семейство (всички)');
      fillSelect(el.ddTYPE, uniqueSorted(vals.TYPE), 'Тип (всички)');
      fillSelect(el.ddORDER, uniqueSorted(vals.ORDER), 'Разред (всички)');
    }

    function normalize(v) {
      if (v == null) return '';
      try { return String(v).toLowerCase().normalize('NFD').replace(/\p{Diacritic}/gu,''); }
      catch(e) { return String(v).toLowerCase(); }
    }

    function isTruthy(v) {
      if (v === null || v === undefined) return false;
      const s = String(v).trim().toLowerCase();
      return ['1','y','yes','true','да'].includes(s) || s.startsWith('y') || s.startsWith('д');
    }

    function speciesKey(props = {}) {
      const la = (props.LATIN_NAME || '').trim();
      const bg = (props.BG_NAME || '').trim();
      return `${la}||${bg}`;
    }

    function getFeatureLink(props = {}) {
      const cand = props.ARTICLE_URL || props.LINK || props.URL || props.WEB || props.WIKI || props.WIKIPEDIA;
      if (!cand) return null;
      let href = String(cand).trim();
      if (!href) return null;
      if (!/^https?:\/\//i.test(href)) href = 'https://' + href;
      try { new URL(href); return href; } catch { return null; }
    }

    /* ---------- Статус мапване + tooltip ---------- */
    const STATUS_TITLES = {
      lc:'LC — Незастрашен',
      nt:'NT — Почти застрашен',
      vu:'VU — Уязвим',
      en:'EN — Застрашен',
      cr:'CR — Критично застрашен',
      dd:'DD — Недостатъчно данни',
      ex:'EX — Изчезнал'
    };
    function statusToCode(raw){
      if (!raw) return null;
      const s = String(raw).toLowerCase().trim();
      if (/(незастрашен|least concern|^lc\b)/.test(s)) return 'lc';
      if (/(почти застрашен|near threatened|^nt\b)/.test(s)) return 'nt';
      if (/(уязвим|vulnerable|^vu\b)/.test(s)) return 'vu';
      if (/(застрашен|endangered|^en\b)/.test(s)) return 'en';
      if (/(критично|critically endangered|^cr\b)/.test(s)) return 'cr';
      if (/(недостатъчно данни|data deficient|^dd\b)/.test(s)) return 'dd';
      if (/(изчезнал|extinct|^ex\b)/.test(s)) return 'ex';
      return null;
    }

    /* ----------- Селекция по вид: помощни ----------- */
    function boundsForMarkers(markers){
      if (!markers || !markers.length) return null;
      const latLngs = markers.map(m => m.getLatLng());
      return L.latLngBounds(latLngs);
    }

    function filterMarkersToSelectedSpecies(){
      state.pointMarkerLayer.clearLayers();
      for (const m of state.currentMarkers) m._icon?.classList.remove('highlight');

      if (!state.selectedSpeciesKey){
        for (const m of state.currentMarkers) state.pointMarkerLayer.addLayer(m);
        const speciesCount = new Set(state.filteredPoints.map(f => speciesKey(f.properties))).size;
        document.getElementById('count').textContent =
          `Намерени видове: ${speciesCount} (точки: ${state.filteredPoints.length})`;
        return;
      }
      const group = state.currentMarkersByKey.get(state.selectedSpeciesKey) || [];
      for (const m of group){
        state.pointMarkerLayer.addLayer(m);
        m._icon?.classList.add('highlight');
      }
      document.getElementById('count').textContent =
        `Намерени видове: 1 (точки: ${group.length})`;
    }

    /* ---------- Основен филтър и рендер ---------- */
    function applyFiltersAndRender() {
      if (!state.selectedPolygonFeature && (!state.explodedPoints || !state.explodedPoints.length)) {
        setGlobalExplodedFromActive();
        populateFilterDropdowns(state.explodedPoints);
      }

      const search = normalize(el.search.value);
      const sel = {
        STATUS: el.ddSTATUS.value,
        FAMILY: el.ddFAMILY.value,
        TYPE: el.ddTYPE.value,
        ORDER: el.ddORDER.value,
        ENDEMIC: el.cbENDEMIC.checked,
        RELICT: el.cbRELICT.checked
      };

      const base = state.explodedPoints || [];
      const filtered = [];
      for (const f of base) {
        const p = f.properties || {};
        const nameBG = normalize(p.BG_NAME);
        const nameLA = normalize(p.LATIN_NAME);

        const anyFilterOn = search || sel.STATUS || sel.FAMILY || sel.TYPE || sel.ORDER || sel.ENDEMIC || sel.RELICT;
        if (!state.selectedPolygonFeature && !anyFilterOn) continue;

        if (search && !(nameBG.includes(search) || nameLA.includes(search))) continue;

        if (sel.STATUS && String(p.STATUS) !== sel.STATUS) continue;
        if (sel.FAMILY && String(p.FAMILY) !== sel.FAMILY) continue;
        if (state.activePts === 'animals') {
          if (sel.TYPE  && String(p.TYPE)  !== sel.TYPE)  continue;
          if (sel.ORDER && String(p.ORDER) !== sel.ORDER) continue;
        }
        if (sel.ENDEMIC && !isTruthy(p.ENDEMIC)) continue;
        if (sel.RELICT  && !isTruthy(p.RELICT))  continue;

        filtered.push(f);
      }

      state.filteredPoints = filtered;

      if (!state.selectedPolygonFeature && !(search || sel.STATUS || sel.FAMILY || sel.TYPE || sel.ORDER || sel.ENDEMIC || sel.RELICT)) {
        el.count.textContent = 'Въведете търсене или изберете филтър.';
        el.list.innerHTML = '';
        state.pointMarkerLayer.clearLayers();
        return;
      }

      renderListAndMarkers(filtered);
    }

    function renderListAndMarkers(features) {
      const totalPoints = features.length;

      el.list.innerHTML = '';
      state.pointMarkerLayer.clearLayers();
      state.currentMarkers = [];
      state.currentMarkersByKey = new Map();

      if (!features.length) {
        el.count.textContent = 'Няма съвпадения.';
        return;
      }

      // Маркери
      for (const f of features) {
        const [lng, lat] = f.geometry.coordinates;
        const p = f.properties || {};
        const key = speciesKey(p);

        const marker = L.marker([lat, lng], {
          icon: L.divIcon({ className: 'pt-marker', iconSize: [10,10] }),
          title: (p.BG_NAME || p.LATIN_NAME || 'Point')
        }).addTo(state.pointMarkerLayer);

        marker.on('click', () => openPopupAt([lat, lng], p));
        marker._speciesKey = key;

        state.currentMarkers.push(marker);
        if (!state.currentMarkersByKey.has(key)) state.currentMarkersByKey.set(key, []);
        state.currentMarkersByKey.get(key).push(marker);
      }

      const uniqueList = [];
      for (const [key, markers] of state.currentMarkersByKey.entries()) {
        const rep = features.find(ft => speciesKey(ft.properties) === key) || {};
        uniqueList.push({ key, count: markers.length, props: rep.properties || {} });
      }

      uniqueList.sort((a,b)=>{
        const an = (a.props.BG_NAME || a.props.LATIN_NAME || '').toLowerCase();
        const bn = (b.props.BG_NAME || b.props.LATIN_NAME || '').toLowerCase();
        return an.localeCompare(bn,'bg',{sensitivity:'base'});
      });

      // Списък
      for (const item of uniqueList) {
        const p = item.props;

        const row = document.createElement('div');
        row.className = 'feature-item';

        /* 1) BADGE RAIL */
        const rail = document.createElement('div');
        rail.className = 'feature-badges';
        if (isTruthy(p.ENDEMIC)) {
          const b = document.createElement('span');
          b.className = 'chip chip--endemic';
          b.textContent = 'Ендемит';
          rail.appendChild(b);
        }
        if (isTruthy(p.RELICT)) {
          const b = document.createElement('span');
          b.className = 'chip chip--relict';
          b.textContent = 'Реликт';
          rail.appendChild(b);
        }
        row.appendChild(rail);

        /* 2) NAMES + META */
        const names = document.createElement('div');
        names.className = 'feature-names';

        const nameBG = document.createElement('div');
        nameBG.className = 'name-bg';
        nameBG.textContent = p.BG_NAME || '';

        const nameLA = document.createElement('div');
        nameLA.className = 'name-la';
        nameLA.textContent = p.LATIN_NAME ? `(${p.LATIN_NAME})` : '';

        names.appendChild(nameBG);
        names.appendChild(nameLA);

        const meta = document.createElement('div');
        meta.className = 'feature-meta';

        // Статус-чип с tooltip
        const code = statusToCode(p.STATUS);
        if (code){
          const st = document.createElement('span');
          st.className = `chip chip--st ${code}`;
          st.textContent = p.STATUS;                 // показвай пълния текст
          st.title = STATUS_TITLES[code] || p.STATUS; // tooltip
          meta.appendChild(st);
        }

        if (p.FAMILY){
          const fam = document.createElement('span');
          fam.textContent = p.FAMILY;
          meta.appendChild(fam);
        }
        if (p.TYPE && state.activePts === 'animals'){
          const typ = document.createElement('span');
          typ.textContent = p.TYPE;
          meta.appendChild(typ);
        }
        if (typeof item.count === 'number'){
          const cnt = document.createElement('span');
          cnt.className = 'chip';
          cnt.style.background = '#eef';
          cnt.style.borderColor = '#ccd';
          cnt.title = 'Брой точки за вида';
          cnt.textContent = item.count;
          meta.appendChild(cnt);
        }

        names.appendChild(meta);
        row.appendChild(names);

        /* 3) BUTTON */
        const linkHref = getFeatureLink(p);
        const btn = document.createElement('button');
        btn.className = 'link-btn';
        btn.textContent = 'Отвори статия';
        btn.disabled = !linkHref;
        btn.title = linkHref ? 'Отваря статия в нов таб' : 'Няма наличен линк';
        btn.addEventListener('click', (ev) => {
          ev.stopPropagation();
          if (linkHref) window.open(linkHref, '_blank', 'noopener');
        });
        row.appendChild(btn);

        // КЛИК ПО РЕД → филтър + плавен зум
        row.onclick = () => {
          state.selectedSpeciesKey = item.key;
          filterMarkersToSelectedSpecies();

          const group = state.currentMarkersByKey.get(item.key) || [];
          if (!group.length) return;
          const bnds = boundsForMarkers(group);

          if (group.length === 1) {
            map.flyTo(group[0].getLatLng(), Math.min(map.getMaxZoom(), 12), { duration: 0.8 });
          } else {
            map.flyToBounds(bnds, { padding: [40,40], maxZoom: 12, duration: 0.8 });
          }
        };

        el.list.appendChild(row);
      }

      // Обнови брояча (по подразбиране – всички филтрирани)
      el.count.textContent = `Намерени видове: ${uniqueList.length} (точки: ${totalPoints})`;

      // Ако има активна селекция по вид, приложи филтъра
      if (state.selectedSpeciesKey) filterMarkersToSelectedSpecies();
    }

    function openPopupAt(latlng, props) {
      const rows = [];
      const link = getFeatureLink(props);
      if (link) {
        rows.push(`
          <tr>
            <th style="text-align:left; padding-right:8px">Линк</th>
            <td><a href="${escapeHTML(link)}" target="_blank" rel="noopener">Отвори статия</a></td>
          </tr>`);
      }
      const keysOrder = ['BG_NAME','LATIN_NAME','STATUS','TYPE','ORDER','FAMILY','ENDEMIC','RELICT'];
      for (const k of keysOrder) {
        if (props[k] !== undefined) {
          rows.push(`
            <tr>
              <th style="text-align:left; padding-right:8px">${escapeHTML(k)}</th>
              <td>${escapeHTML(props[k])}</td>
            </tr>`);
        }
      }
      for (const k of Object.keys(props)) {
        if (!keysOrder.includes(k)) {
          rows.push(`
            <tr>
              <th style="text-align:left; padding-right:8px">${escapeHTML(k)}</th>
              <td>${escapeHTML(props[k])}</td>
            </tr>`);
        }
      }
      const html = `<table style="font-size:13px">${rows.join('')}</table>`;
      L.popup().setLatLng(latlng).setContent(html).openOn(map);
    }

    /* ---------- Controls / Events ---------- */
    function wireControls() {
      document.querySelectorAll('input[name="poly"]').forEach(r => {
        r.addEventListener('change', () => {
          map.removeLayer(layers.poly[state.activePoly]);
          if (state.selectedPolygonLayer) {
            try { state.selectedPolygonLayer.setStyle(BASE_STYLES[state.activePoly]); } catch(e){}
          }
          state.activePoly = r.value;
          map.addLayer(layers.poly[state.activePoly]);

          // Нулирай селекцията по вид
          state.selectedSpeciesKey = null;
          clearSelection();
        });
      });

      document.querySelectorAll('input[name="points"]').forEach(r => {
        r.addEventListener('change', () => {
          state.activePts = r.value;
          state.selectedSpeciesKey = null; // нулирай при смяна на книга
          refreshFilterVisibility();
          if (state.selectedPolygonFeature) {
            onPolygonClick(state.selectedPolygonFeature, state.selectedPolygonLayer);
          } else {
            setGlobalExplodedFromActive();
            populateFilterDropdowns(state.explodedPoints);
            applyFiltersAndRender();
          }
        });
      });

      let t;
      el.search.addEventListener('input', () => {
        clearTimeout(t);
        t = setTimeout(() => { state.selectedSpeciesKey = null; applyFiltersAndRender(); }, 300);
      });

      [el.ddSTATUS, el.ddFAMILY, el.ddTYPE, el.ddORDER, el.cbENDEMIC, el.cbRELICT]
        .forEach(ctrl => {
          ctrl.addEventListener('change', () => { state.selectedSpeciesKey = null; applyFiltersAndRender(); });
        });

      el.btnClearFilters.addEventListener('click', () => {
        el.search.value = '';
        [el.ddSTATUS, el.ddFAMILY, el.ddTYPE, el.ddORDER].forEach(sel => sel.value = '');
        el.cbENDEMIC.checked = false;
        el.cbRELICT.checked  = false;
        state.selectedSpeciesKey = null;
        applyFiltersAndRender();
      });

      el.btnClearSel.addEventListener('click', () => {
        state.selectedSpeciesKey = null;
        clearSelection();

        if (state.selectedPolygonLayer) {
          map.fitBounds(state.selectedPolygonLayer.getBounds(), { padding: [30,30], maxZoom: 8 });
        } else {
          fitToMorphBG();
        }
      });
    }

    function clearSelection() {
      if (state.selectedPolygonLayer) {
        try { state.selectedPolygonLayer.setStyle(BASE_STYLES[state.activePoly]); } catch(e){}
      }
      state.selectedPolygonLayer = null;
      state.selectedPolygonFeature = null;

      setGlobalExplodedFromActive();
      populateFilterDropdowns(state.explodedPoints);

      state.filteredPoints = [];
      state.pointMarkerLayer.clearLayers();
      for (const m of state.currentMarkers) { m._icon?.classList.remove('highlight'); }
      el.list.innerHTML = '';
      el.count.textContent = 'Въведете търсене или изберете филтър.';
    }

    function refreshFilterVisibility() {
      const isAnimals = state.activePts === 'animals';
      el.rowTypeOrder.classList.toggle('hidden', !isAnimals);
    }

    function escapeHTML(v) {
      if (v===null || v===undefined) return '';
      return String(v)
        .replaceAll('&','&amp;')
        .replaceAll('<','&lt;')
        .replaceAll('>','&gt;')
        .replaceAll('"','&quot;')
        .replaceAll("'",'&#39;');
    }
  </script>
</body>
</html>
