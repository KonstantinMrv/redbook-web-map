<!DOCTYPE html>
<html lang="bg">
<head>
  <meta charset="utf-8" />
  <title>Червената книга на България – ГИС платформа</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">

  <!-- Leaflet CSS -->
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"/>

  <style>
    :root{
      --pad:12px; --gap:8px; --radius:10px;

      /* Badge / chip styling */
      --chip-radius: 999px;
      --chip-px: 8px; --chip-py: 3px;

      /* Endemic / Relict */
      --gold-bg:#F7E9B5; --gold-bd:#E3C676; --gold-tx:#7A5C00;
      --purp-bg:#E8D9F7; --purp-bd:#C3ACE6; --purp-tx:#4B2E83;

      /* Status scale (soft) */
      --st-lc-bg:#E6F4EA; --st-lc-bd:#B7E1C1; --st-lc-tx:#1B5E20; /* LC */
      --st-nt-bg:#FFF8E1; --st-nt-bd:#FFE39B; --st-nt-tx:#8C6D1F; /* NT */
      --st-vu-bg:#FFF3CD; --st-vu-bd:#FFE08A; --st-vu-tx:#7A5E00; /* VU */
      --st-en-bg:#FFE0B2; --st-en-bd:#FFCC80; --st-en-tx:#8B3E00; /* EN */
      --st-cr-bg:#FFCDD2; --st-cr-bd:#F5A3AB; --st-cr-tx:#B71C1C; /* CR */
      --st-dd-bg:#E3F2FD; --st-dd-bd:#BBDEFB; --st-dd-tx:#0D47A1; /* DD */
      --st-ex-bg:#111111; --st-ex-bd:#000000; --st-ex-tx:#FFFFFF; /* EX */
    }

    /* Без хоризонтален скрол на страницата */
    *, *::before, *::after { box-sizing: border-box; }
    html, body{
      height:100%; margin:0; font-family:system-ui, Arial, sans-serif;
      overflow-x: hidden;
    }

    #map { position:absolute; inset:0; }

    /* Фиксиран панел; скрол само в списъка */
    #sidebar{
      position:absolute; top:10px; right:10px;
      width:500px; max-width:calc(100vw - 20px);
      height:94vh;                           /* леко над OSM надписа */
      background:#fff; padding:var(--pad);
      border-radius:var(--radius); box-shadow:0 6px 18px rgba(0,0,0,.25);
      z-index:9999;

      display:flex; flex-direction:column;
      overflow:hidden;                        /* без скрол на панела */
    }
    #sidebar h3{
      margin:0 0 var(--gap) 0;
      text-align:center;
    }

    .controls{ flex:0 0 auto; overflow:hidden; }
    .controls section{ margin-bottom:10px; }
    .controls label{ display:block; margin:4px 0; cursor:pointer; }

    /* Гридове без преливане */
    .row{
      display:grid;
      grid-template-columns: minmax(0,1fr) minmax(0,1fr);
      gap:var(--gap);
    }
    .row > *{ min-width:0; }

    /* Форм елементи – на 100% вътре в панела */
    input[type="text"], select{
      width:100%; max-width:100%; display:block;
      padding:8px; border:1px solid #ccc; border-radius:6px; font-size:14px;
      min-width:0;
    }
    #sidebar select{ text-overflow:ellipsis; white-space:nowrap; overflow:hidden; }

    label{ overflow-wrap:anywhere; word-break:break-word; }

    .checkline{ display:flex; align-items:center; gap:8px; }

    /* Бутони – центрирани и равномерни */
    .btnbar{
      display:flex; justify-content:space-evenly; align-items:center;
      gap:var(--gap); margin:6px 0 10px;
    }
    .btnbar button{
      padding:8px 10px; border-radius:8px; border:1px solid #ccc;
      background:#f6f6f6; cursor:pointer; min-width:150px;
    }
    .btnbar button:hover{ background:#eee; }

    #count{ margin:6px 0; font-weight:600; flex:0 0 auto; }

    /* Списъкът – вертикален скрол тук */
    #list{
      border-top:1px solid #ddd; margin-top:6px;
      flex:1 1 auto; min-height:0;
      overflow-y:auto; overflow-x:hidden;
    }

    .legend{ font-size:12px; color:#666; }
    .muted{ color:#666; }
    .hidden{ display:none !important; }

    /* Маркери */
    .pt-marker{
      background:#1f78b4; width:8px; height:8px; border-radius:50%; border:1px solid #fff;
      box-shadow:0 0 0 1px rgba(0,0,0,.15);
    }
    .pt-marker.highlight{ background:#ff7f0e; }

    /* Етикети на полигони */
    .poly-label{
      background:rgba(255,255,255,0.75);
      padding:2px 6px; border-radius:8px; border:1px solid #ccc;
      font-size:12px; color:#333; box-shadow:0 1px 3px rgba(0,0,0,.15);
    }
    .leaflet-interactive.hovered{ stroke-width:3px !important; filter:brightness(1.2); }

    /* ---------- Ред в списъка: Текст | Бадж-рейл | Бутон ---------- */
    .feature-item{
      display:grid;
      grid-template-columns: 1fr 88px 120px; /* (ляво) текст | (дясно) бадж-рейл | бутон */
      align-items:center;
      gap:10px;
      min-height:64px;
      padding:10px 8px;
      border-bottom:1px solid #eee;
      cursor:pointer;
      position:relative;
    }
    .feature-item:hover{ background:#faf6e8; }

    /* Колона 2: релса за баджове (вдясно) */
    .feature-badges{
      display:flex; flex-direction:column; align-items:flex-end; justify-content:center;
      gap:6px; min-height:40px;
    }
    .feature-badges .chip{ min-width:70px; justify-content:center; }

    /* Колона 1: имена + мета (вляво) */
    .feature-names{ display:flex; flex-direction:column; gap:2px; min-width:0; }
    .feature-names .name-bg{
      font-weight:600; line-height:1.2; overflow:hidden; text-overflow:ellipsis; white-space:nowrap;
    }
    .feature-names .name-la{
      font-style:italic; font-size:0.875rem; color:#4b5563; opacity:.95; line-height:1.05;
      overflow:hidden; text-overflow:ellipsis; white-space:nowrap;
    }
    .feature-meta{
      margin-top:4px; font-size:12px; color:#666; display:flex; gap:6px; align-items:center; flex-wrap:wrap;
    }

    /* Чипове / баджове */
    .chip{
      display:inline-flex; align-items:center; gap:6px;
      padding: var(--chip-py) var(--chip-px);
      border-radius: var(--chip-radius);
      border:1px solid transparent;
      font-size:11px; line-height:1;
      white-space:nowrap;
    }
    .chip--endemic{ background:var(--gold-bg); border-color:var(--gold-bd); color:var(--gold-tx); }
    .chip--relict{  background:var(--purp-bg); border-color:var(--purp-bd); color:var(--purp-tx); }

    /* Статус чипове */
    .chip--st{ font-weight:600; }
    .chip--st.lc{ background:var(--st-lc-bg); border-color:var(--st-lc-bd); color:var(--st-lc-tx); }
    .chip--st.nt{ background:var(--st-nt-bg); border-color:var(--st-nt-bd); color:var(--st-nt-tx); }
    .chip--st.vu{ background:var(--st-vu-bg); border-color:var(--st-vu-bd); color:var(--st-vu-tx); }
    .chip--st.en{ background:var(--st-en-bg); border-color:var(--st-en-bd); color:var(--st-en-tx); }
    .chip--st.cr{ background:var(--st-cr-bg); border-color:var(--st-cr-bd); color:var(--st-cr-tx); }
    .chip--st.dd{ background:var(--st-dd-bg); border-color:var(--st-dd-bd); color:var(--st-dd-tx); }
    .chip--st.ex{ background:var(--st-ex-bg); border-color:var(--st-ex-bd); color:var(--st-ex-tx); }

    /* По-тих брояч */
    .chip--count{ background:#EEF1FF; border-color:#D7DBFF; color:#4b4f7a; font-weight:600; padding:2px 6px; }

    /* Десният бутон */
    .link-btn{
      width:120px; text-align:center; padding:6px 8px; font-size:12px;
      border-radius:6px; border:1px solid #ccc; background:#f4f6ff; cursor:pointer; white-space:nowrap;
    }
    .link-btn:hover{ background:#e9edff; }
    .link-btn:disabled{ opacity:.6; cursor:not-allowed; background:#f0f0f0; color:#888; }

    /* Зонов dropdown ред (компактен) */
    .zones-row { margin-top:6px; }
    .zones-label { font-weight: 600; font-size: 13px; color:#333; margin-bottom:4px; }
  </style>
</head>
<body>
  <div id="map"></div>

  <div id="sidebar" aria-label="Sidebar">
    <h3>Червената книга на България – ГИС платформа</h3>
    <div class="controls" role="group" aria-label="Controls">
      <section>
        <strong>Основа</strong>
        <label><input type="radio" name="polyMain" value="morph"> Геоморфоложки структури</label>
        <label><input type="radio" name="polyMain" value="land" checked> Ландшафтно райониране</label>

        <label class="checkline" style="margin-top:6px;">
          <input type="radio" name="polyMain" value="zones"> Защитени територии
        </label>
        <div id="zonesLine" class="zones-row hidden">
          <div class="zones-label">Изберете слой</div>
          <select id="ddZones">
            <option value="n2k_birds">Natura 2000 — Зони за птици</option>
            <option value="n2k_habitats">Natura 2000 — Зони по местообитания</option>
            <option value="protected_area">Защитени територии по ЗЗТ</option>
          </select>
        </div>
      </section>

      <section>
        <strong>Книги</strong>
        <label><input type="radio" name="points" value="plants"> Том I. Растения и гъби</label>
        <label><input type="radio" name="points" value="animals" checked> Том II. Животни</label>
      </section>

      <section>
        <input id="searchBox" type="text" placeholder="Търси по наименование" aria-label="Search">
        <div class="row" style="margin-top:8px">
          <select id="ddSTATUS"><option value="">Статус (всички)</option></select>
          <select id="ddFAMILY"><option value="">Семейство (всички)</option></select>
        </div>
        <div class="row" id="rowTypeOrder" style="margin-top:8px">
          <select id="ddTYPE"><option value="">Тип (всички)</option></select>
          <select id="ddORDER"><option value="">Разред (всички)</option></select>
        </div>
        <div class="row" style="margin-top:8px">
          <label class="checkline"><input type="checkbox" id="cbENDEMIC"> Ендемит</label>
          <label class="checkline"><input type="checkbox" id="cbRELICT"> Реликт</label>
        </div>
        <div class="btnbar">
          <button id="btnClearFilters" title="Изчисти всички филтри">Изчисти филтрите</button>
          <button id="btnClearSel" title="Изчисти селекцията от картата">Изчисти селекцията</button>
        </div>
      </section>
    </div>

    <div id="count" class="muted">Въведете търсене или изберете територия от картата.</div>
    <div id="list" role="list" aria-label="Result list"></div>
  </div>

  <!-- Leaflet & Turf -->
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@turf/turf@6/turf.min.js"></script>

  <script>
    /* ---------- CONFIG: точки ---------- */
    const ANIMALS_GEOJSON_URL = 'data/Animals.geojson';
    const PLANTS_FUNGI_GEOJSON_URL = 'data/PlantsFungi.geojson';

    /* ---------- POLYGON LAYERS CONFIG ---------- */
    const POLY_DEFS = {
      morph: {
        url: 'data/morph_units.geojson',
        label: 'Геоморфоложки структури',
        baseStyle: { color:'#B08D57', weight:1,   fillColor:'#F3E5AB', fillOpacity:.65 },
        selStyle:  { color:'#B08D57', weight:4,   fillColor:'#FFF4C9', fillOpacity:.8 },
        layer: null, loaded: false
      },
      land: {
        url: 'data/landscape_zoning.geojson',
        label: 'Ландшафтно райониране',
        baseStyle: { color:'#5A8F68', weight:1,   fillColor:'#CDE8B8', fillOpacity:.65 },
        selStyle:  { color:'#5A8F68', weight:4,   fillColor:'#E9F6D8', fillOpacity:.8 },
        layer: null, loaded: false
      },
      n2k_birds: {
        url: 'data/N2000_Birds.geojson',
        label: 'Natura 2000 — Зони за птици',
        baseStyle: { color:'#1E88E5', weight:1.2, fillColor:'#BBDEFB', fillOpacity:.35 },
        selStyle:  { color:'#1565C0', weight:3,   fillColor:'#E3F2FD', fillOpacity:.55 },
        layer: null, loaded: false
      },
      n2k_habitats: {
        url: 'data/N2000_habitatss.geojson',
        label: 'Natura 2000 — Зони по местообитания',
        baseStyle: { color:'#43A047', weight:1.2, fillColor:'#C8E6C9', fillOpacity:.35 },
        selStyle:  { color:'#2E7D32', weight:3,   fillColor:'#E8F5E9', fillOpacity:.55 },
        layer: null, loaded: false
      },
      protected_area: {
        url: 'data/protected_area.geojson',
        label: 'Защитени територии по ЗЗТ',
        baseStyle: { color:'#8E24AA', weight:1.2, fillColor:'#E1BEE7', fillOpacity:.35 },
        selStyle:  { color:'#6A1B9A', weight:3,   fillColor:'#F3E5F5', fillOpacity:.55 },
        layer: null, loaded: false
      }
    };

    /* ---------- MAP (с безопасна инициализация) ---------- */
    let map = null;

    async function waitForLeaflet(maxWaitMs = 3000) {
      const start = performance.now();
      while (!window.L) {
        await new Promise(r => setTimeout(r, 20));
        if (performance.now() - start > maxWaitMs) {
          throw new Error('Leaflet (window.L) не е наличен.');
        }
      }
    }

    const mapReady = (async () => {
      await waitForLeaflet();
      map = L.map('map', { zoomControl: true }).setView([42.75, 25.3], 7);
      L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
        maxZoom: 20,
        attribution: '&copy; OpenStreetMap'
      }).addTo(map);
      map.options.maxBoundsViscosity = 1.0;  // лепкавост по ръбовете
      state.pointMarkerLayer = L.layerGroup().addTo(map);
      return true;
    })();

    /* ---------- STATE ---------- */
    const state = {
      activePolyMain: 'land',        // 'morph' | 'land' | 'zones'
      activePoly:     'land',        // реалният ключ в POLY_DEFS
      activePts:      'animals',     // 'animals' | 'plants'
      selectedPolygonFeature: null,
      selectedPolygonLayer: null,
      explodedPoints: [],
      filteredPoints: [],
      pointMarkerLayer: null,
      currentMarkers: [],
      currentMarkersByKey: new Map(),
      selectedSpeciesKey: null
    };

    /* ---------- UI elements ---------- */
    const el = {
      search: document.getElementById('searchBox'),
      ddSTATUS: document.getElementById('ddSTATUS'),
      ddFAMILY: document.getElementById('ddFAMILY'),
      ddTYPE: document.getElementById('ddTYPE'),
      ddORDER: document.getElementById('ddORDER'),
      cbENDEMIC: document.getElementById('cbENDEMIC'),
      cbRELICT: document.getElementById('cbRELICT'),
      rowTypeOrder: document.getElementById('rowTypeOrder'),
      btnClearFilters: document.getElementById('btnClearFilters'),
      btnClearSel: document.getElementById('btnClearSel'),
      list: document.getElementById('list'),
      count: document.getElementById('count'),
      zonesLine: document.getElementById('zonesLine'),
      ddZones: document.getElementById('ddZones')
    };

    /* ---------- Данни за точки ---------- */
    const layers = { data: {} };

    /* ---------- Lazy loader за полигонов слой ---------- */
    async function ensurePolyLayer(key){
      const def = POLY_DEFS[key];
      if (!def) return null;
      if (def.loaded && def.layer) return def.layer;

      const gj = await fetch(def.url).then(r=>r.json());
      def.layer = L.geoJSON(gj, {
        style: def.baseStyle,
        onEachFeature: (f, l) => {
          l.on({
            mouseover: e => { if (e?.target?._path) e.target._path.classList.add('hovered'); },
            mouseout:  e => { if (e?.target?._path) e.target._path.classList.remove('hovered'); },
            click:     () => onPolygonClick(f, l)
          });
          const nm = (f.properties && (f.properties.NAME || f.properties.Name || f.properties.name)) || '';
          if (nm) l.bindTooltip(nm, { permanent:true, direction:'center', className:'poly-label' });
        }
      });
      def.loaded = true;
      return def.layer;
    }

    /* ---- Модулен авто-fit с десен padding към сайдпанела ---- */
    function lockInitialExtentFrom(bounds) {
      try {
        if (!bounds || !bounds.isValid()) return;
        const initialZoom = map.getZoom();
        map.setMinZoom(initialZoom);           // не може да се зуумаутва повече от началния
        map.setMaxBounds(bounds.pad(0.05));    // ограничение по рамка (лек пад)
        map.options.maxBoundsViscosity = 1.0;  // лепкавост
      } catch (e) { console.warn('lockInitialExtentFrom() грешка:', e); }
    }

    /**
     * Автоматичен fit към активния полигонов слой с отчитане на ширината на сайдпанела.
     * @param {{lock?: boolean, refitOnly?: boolean}} opts
     *   lock: ако е true – след приключване на fit веднъж се заключва началният обхват по текущите граници
     *   refitOnly: ако е true – само преизчислява padding и re-fit-ва без да пипа minZoom/maxBounds
     */
    function fitToActivePolyWithSidebar({ lock = false, refitOnly = false } = {}) {
      const def = POLY_DEFS[state.activePoly];
      if (!def?.layer) return;

      let bounds = def.layer.getBounds();
      if (!bounds || !bounds.isValid()) return;

      // Леко разширяване, за да не се "реже" нищо по ръбовете
      try { bounds = bounds.pad(0.015); } catch(_) {}

      // Изчисли десния padding според ширината на сайдпанела
      const sidebar = document.getElementById('sidebar');
      const mapEl = document.getElementById('map');
      const sidebarW = sidebar ? Math.round(sidebar.getBoundingClientRect().width) : 0;
      const mapW = mapEl ? mapEl.clientWidth : window.innerWidth;

      // реална ширина на панела + малък буфер, но не повече от 55% от ширината на картата
      const rightPad = Math.min(sidebarW + 24, Math.round(mapW * 0.55));
      const padTL = [16, 16];
      const padBR = [16 + rightPad, 16];

      // За да няма „подскачане“
      map.invalidateSize();

      // Изчисли максимално близкия zoom, който побира bounds с падинги, и му позволи +1 ниво
      const targetZoom = map.getBoundsZoom(bounds, true, { paddingTopLeft: padTL, paddingBottomRight: padBR });
      const startMaxZoom = Math.min((targetZoom + 1), 12, map.getMaxZoom?.() ?? 12);

      const doFit = () => {
        map.fitBounds(bounds, {
          paddingTopLeft: padTL,
          paddingBottomRight: padBR,
          maxZoom: startMaxZoom
        });
      };

      if (lock && !refitOnly) {
        const once = () => {
          map.off('moveend', once);
          lockInitialExtentFrom(bounds);
        };
        map.once('moveend', once);
      }

      doFit();
    }

    /* ---- Refit при window resize, без промяна на ограниченията ---- */
    (function () {
      let t;
      window.addEventListener('resize', () => {
        clearTimeout(t);
        t = setTimeout(() => fitToActivePolyWithSidebar({ refitOnly: true }), 100);
      });
    })();

    /* ---------- Helpers ---------- */
    function explodeMultiPoints(fc) {
      const out = [];
      for (const f of fc.features) {
        if (!f || !f.geometry) continue;
        if (f.geometry.type === 'MultiPoint') {
          for (const c of f.geometry.coordinates) {
            out.push({ type: 'Feature', geometry: { type: 'Point', coordinates: c }, properties: { ...f.properties } });
          }
        } else if (f.geometry.type === 'Point') {
          out.push(f);
        }
      }
      return out;
    }

    function setGlobalExplodedFromActive() {
      const fc = layers.data[state.activePts];
      state.explodedPoints = explodeMultiPoints(fc);
    }

    function onPolygonClick(feature, layer) {
      if (state.selectedPolygonLayer) {
        try { state.selectedPolygonLayer.setStyle(POLY_DEFS[state.activePoly].baseStyle); } catch(e){}
      }
      state.selectedPolygonLayer = layer;
      state.selectedPolygonFeature = feature;
      layer.setStyle(POLY_DEFS[state.activePoly].selStyle);

      const exploded = explodeMultiPoints(layers.data[state.activePts]);
      const inside = [];
      for (const pt of exploded) if (turf.booleanPointInPolygon(pt, feature)) inside.push(pt);
      state.explodedPoints = inside;

      populateFilterDropdowns(inside);
      applyFiltersAndRender();
    }

    function uniqueSorted(values) {
      return [...new Set(values.filter(v => v !== null && v !== undefined && String(v).trim() !== ''))]
        .map(String).sort((a,b)=>a.localeCompare(b,'bg',{sensitivity:'base'}));
    }

    function fillSelect(sel, values, firstLabel) {
      const current = sel.value;
      sel.innerHTML = '';
      const mk = (val, label) => {
        const opt = document.createElement('option');
        opt.value = val;
        opt.textContent = label ?? val;
        return opt;
      };
      sel.appendChild(mk('', firstLabel || '(всички)'));
      for (const v of values) { if (v !== '') sel.appendChild(mk(v, v)); }
      if ([...sel.options].some(o=>o.value===current)) sel.value = current;
    }

    function populateFilterDropdowns(features) {
      const vals = { STATUS:[], FAMILY:[], TYPE:[], ORDER:[] };
      for (const f of features) {
        const p = f.properties || {};
        if (p.STATUS!=null) vals.STATUS.push(p.STATUS);
        if (p.FAMILY!=null) vals.FAMILY.push(p.FAMILY);
        if (p.TYPE!=null)   vals.TYPE.push(p.TYPE);
        if (p.ORDER!=null)  vals.ORDER.push(p.ORDER);
      }
      fillSelect(el.ddSTATUS, uniqueSorted(vals.STATUS), 'Природозащитен статус (всички)');
      fillSelect(el.ddFAMILY, uniqueSorted(vals.FAMILY), 'Семейство (всички)');
      fillSelect(el.ddTYPE,   uniqueSorted(vals.TYPE),   'Тип (всички)');
      fillSelect(el.ddORDER,  uniqueSorted(vals.ORDER),  'Разред (всички)');
    }

    function normalize(v) {
      if (v == null) return '';
      try { return String(v).toLowerCase().normalize('NFD').replace(/\p{Diacritic}/gu,''); }
      catch(e) { return String(v).toLowerCase(); }
    }

    function isTruthy(v) {
      if (v === null || v === undefined) return false;
      const s = String(v).trim().toLowerCase();
      return ['1','y','yes','true','да'].includes(s) || s.startsWith('y') || s.startsWith('д');
    }

    function speciesKey(props = {}) {
      const la = (props.LATIN_NAME || '').trim();
      const bg = (props.BG_NAME || '').trim();
      return `${la}||${bg}`;
    }

    function getFeatureLink(props = {}) {
      const cand = props.ARTICLE_URL || props.LINK || props.URL || props.WEB || props.WIKI || props.WIKIPEDIA;
      if (!cand) return null;
      let href = String(cand).trim();
      if (!href) return null;
      if (!/^https?:\/\//i.test(href)) href = 'https://' + href;
      try { new URL(href); return href; } catch { return null; }
    }

    /* ---------- Статус мапване ---------- */
    const STATUS_TITLES = {
      lc:'LC — Незастрашен',
      nt:'NT — Почти застрашен',
      vu:'VU — Уязвим',
      en:'EN — Застрашен',
      cr:'CR — Критично застрашен',
      dd:'DD — Недостатъчно данни',
      ex:'EX — Изчезнал'
    };
    function statusToCode(raw){
      if (!raw) return null;
      const s = String(raw).toLowerCase().trim();
      if (/(незастрашен|least concern|^lc\b)/.test(s)) return 'lc';
      if (/(почти застрашен|near threatened|^nt\b)/.test(s)) return 'nt';
      if (/(уязвим|vulnerable|^vu\b)/.test(s)) return 'vu';
      if (/(застрашен|endangered|^en\b)/.test(s)) return 'en';
      if (/(критично|critically endangered|^cr\b)/.test(s)) return 'cr';
      if (/(недостатъчно данни|data deficient|^dd\b)/.test(s)) return 'dd';
      if (/(изчезнал|extinct|^ex\b)/.test(s)) return 'ex';
      return null;
    }

    /* ----------- Селекция по вид: помощни ----------- */
    function boundsForMarkers(markers){
      if (!markers || !markers.length) return null;
      const latLngs = markers.map(m => m.getLatLng());
      return L.latLngBounds(latLngs);
    }

    function filterMarkersToSelectedSpecies(){
      state.pointMarkerLayer.clearLayers();
      for (const m of state.currentMarkers) m._icon?.classList.remove('highlight');

      if (!state.selectedSpeciesKey){
        for (const m of state.currentMarkers) state.pointMarkerLayer.addLayer(m);
        const speciesCount = new Set(state.filteredPoints.map(f => speciesKey(f.properties))).size;
        el.count.textContent =
          `Намерени видове: ${speciesCount} (общ брой нахождения: ${state.filteredPoints.length})`;
        return;
      }
      const group = state.currentMarkersByKey.get(state.selectedSpeciesKey) || [];
      for (const m of group){
        state.pointMarkerLayer.addLayer(m);
        m._icon?.classList.add('highlight');
      }
      el.count.textContent = `Намерени видове: 1 (общ брой нахождения: ${group.length})`;
    }

    /* ---------- Основен филтър и рендер ---------- */
    function applyFiltersAndRender() {
      if (!state.selectedPolygonFeature && (!state.explodedPoints || !state.explodedPoints.length)) {
        setGlobalExplodedFromActive();
        populateFilterDropdowns(state.explodedPoints);
      }

      const search = normalize(el.search.value);
      const sel = {
        STATUS: el.ddSTATUS.value,
        FAMILY: el.ddFAMILY.value,
        TYPE: el.ddTYPE.value,
        ORDER: el.ddORDER.value,
        ENDEMIC: el.cbENDEMIC.checked,
        RELICT: el.cbRELICT.checked
      };

      const base = state.explodedPoints || [];
      const filtered = [];
      for (const f of base) {
        const p = f.properties || {};
        const nameBG = normalize(p.BG_NAME);
        const nameLA = normalize(p.LATIN_NAME);

        const anyFilterOn = search || sel.STATUS || sel.FAMILY || sel.TYPE || sel.ORDER || sel.ENDEMIC || sel.RELICT;
        if (!state.selectedPolygonFeature && !anyFilterOn) continue;

        if (search && !(nameBG.includes(search) || nameLA.includes(search))) continue;

        if (sel.STATUS && String(p.STATUS) !== sel.STATUS) continue;

        if (state.activePts !== 'animals') {
          if (sel.FAMILY && String(p.FAMILY) !== sel.FAMILY) continue;
        }
        if (state.activePts === 'animals') {
          if (sel.TYPE  && String(p.TYPE)  !== sel.TYPE)  continue;
          if (sel.ORDER && String(p.ORDER) !== sel.ORDER) continue;
        }

        if (sel.ENDEMIC && !isTruthy(p.ENDEMIC)) continue;
        if (sel.RELICT  && !isTruthy(p.RELICT))  continue;

        filtered.push(f);
      }

      state.filteredPoints = filtered;

      if (!state.selectedPolygonFeature && !(search || sel.STATUS || sel.FAMILY || sel.TYPE || sel.ORDER || sel.ENDEMIC || sel.RELICT)) {
        el.count.textContent = 'Въведете търсене или изберете филтър.';
        el.list.innerHTML = '';
        state.pointMarkerLayer.clearLayers();
        return;
      }

      renderListAndMarkers(filtered);
    }

    function renderListAndMarkers(features) {
      const totalPoints = features.length;

      el.list.innerHTML = '';
      state.pointMarkerLayer.clearLayers();
      state.currentMarkers = [];
      state.currentMarkersByKey = new Map();

      if (!features.length) {
        el.count.textContent = 'Няма съвпадения.';
        return;
      }

      // Маркери
      for (const f of features) {
        const [lng, lat] = f.geometry.coordinates;
        const p = f.properties || {};
        const key = speciesKey(p);

        const marker = L.marker([lat, lng], {
          icon: L.divIcon({ className: 'pt-marker', iconSize: [10,10] }),
          title: (p.BG_NAME || p.LATIN_NAME || 'Point')
        }).addTo(state.pointMarkerLayer);

        marker.on('click', () => openPopupAt([lat, lng], p));
        marker._speciesKey = key;

        state.currentMarkers.push(marker);
        if (!state.currentMarkersByKey.has(key)) state.currentMarkersByKey.set(key, []);
        state.currentMarkersByKey.get(key).push(marker);
      }

      const uniqueList = [];
      for (const [key, markers] of state.currentMarkersByKey.entries()) {
        const rep = features.find(ft => speciesKey(ft.properties) === key) || {};
        uniqueList.push({ key, count: markers.length, props: rep.properties || {} });
      }

      uniqueList.sort((a,b)=>{
        const an = (a.props.BG_NAME || a.props.LATIN_NAME || '').toLowerCase();
        const bn = (b.props.BG_NAME || b.props.LATIN_NAME || '').toLowerCase();
        return an.localeCompare(bn,'bg',{sensitivity:'base'});
      });

      // Списък
      for (const item of uniqueList) {
        const p = item.props;

        const row = document.createElement('div');
        row.className = 'feature-item';

        /* 1) ИМЕНА + МЕТА (ляво) */
        const names = document.createElement('div');
        names.className = 'feature-names';

        const nameBG = document.createElement('div');
        nameBG.className = 'name-bg';
        nameBG.textContent = p.BG_NAME || '';

        const nameLA = document.createElement('div');
        nameLA.className = 'name-la';
        nameLA.textContent = p.LATIN_NAME ? `(${p.LATIN_NAME})` : '';

        names.appendChild(nameBG);
        names.appendChild(nameLA);

        const meta = document.createElement('div');
        meta.className = 'feature-meta';

        // Статус-чип – първи
        const code = statusToCode(p.STATUS);
        if (code){
          const st = document.createElement('span');
          st.className = `chip chip--st ${code}`;
          st.title = STATUS_TITLES[code] || p.STATUS;
          const label = (code === 'cr') ? `⚠️ ${p.STATUS}` : p.STATUS;
          st.textContent = label;
          meta.appendChild(st);
        }

        const isAnimals = state.activePts === 'animals';
        if (!isAnimals && p.FAMILY){
          const fam = document.createElement('span');
          fam.textContent = p.FAMILY;
          meta.appendChild(fam);
        }
        if (isAnimals && p.TYPE){
          const typ = document.createElement('span');
          typ.textContent = p.TYPE;
          meta.appendChild(typ);
        }

        if (typeof item.count === 'number'){
          const cnt = document.createElement('span');
          cnt.className = 'chip chip--count';
          cnt.title = 'Брой нахождения за вида';
          cnt.textContent = item.count;
          meta.appendChild(cnt);
        }

        names.appendChild(meta);
        row.appendChild(names);

        /* 2) БАДЖОВЕ (вдясно, преди бутона) */
        const rail = document.createElement('div');
        rail.className = 'feature-badges';
        if (isTruthy(p.ENDEMIC)) {
          const b = document.createElement('span');
          b.className = 'chip chip--endemic';
          b.textContent = 'Ендемит';
          b.title = 'Ендемит — вид, срещащ се само тук';
          rail.appendChild(b);
        }
        if (isTruthy(p.RELICT)) {
          const b = document.createElement('span');
          b.className = 'chip chip--relict';
          b.textContent = 'Реликт';
          b.title = 'Реликт — древен елемент от флора/фауна';
          rail.appendChild(b);
        }
        row.appendChild(rail);

        /* 3) БУТОН (най-вдясно): винаги видим; без линк -> disabled/сив */
        const linkHref = getFeatureLink(p);
        const btn = document.createElement('button');
        btn.className = 'link-btn';
        btn.textContent = 'Отвори статия';
        btn.disabled = !linkHref;
        if (linkHref) {
          btn.title = 'Отваря статия в нов таб';
          btn.addEventListener('click', (ev) => {
            ev.stopPropagation();
            window.open(linkHref, '_blank', 'noopener');
          });
        } else {
          btn.title = 'Няма налична статия';
        }
        row.appendChild(btn);

        // КЛИК ПО РЕД → филтър + плавен зум
        row.onclick = () => {
          state.selectedSpeciesKey = item.key;
          filterMarkersToSelectedSpecies();

          const group = state.currentMarkersByKey.get(item.key) || [];
          if (!group.length) return;
          const bnds = boundsForMarkers(group);

          if (group.length === 1) {
            map.flyTo(group[0].getLatLng(), Math.min(map.getMaxZoom(), 12), { duration: 0.8 });
          } else {
            map.flyToBounds(bnds, { padding: [40,40], maxZoom: 12, duration: 0.8 });
          }
        };

        el.list.appendChild(row);
      }

      // Обнови брояча (по подразбиране – всички филтрирани)
      el.count.textContent = `Намерени видове: ${uniqueList.length} (общ брой нахождения: ${totalPoints})`;

      // Ако има активна селекция по вид, приложи филтъра
      if (state.selectedSpeciesKey) filterMarkersToSelectedSpecies();
    }

    function openPopupAt(latlng, props) {
      const rows = [];
      const link = getFeatureLink(props);
      if (link) {
        rows.push(`
          <tr>
            <th style="text-align:left; padding-right:8px">Линк</th>
            <td><a href="${escapeHTML(link)}" target="_blank" rel="noopener">Отвори статия</a></td>
          </tr>`);
      }
      const keysOrder = ['BG_NAME','LATIN_NAME','STATUS','TYPE','ORDER','FAMILY','ENDEMIC','RELICT'];
      for (const k of keysOrder) {
        if (props[k] !== undefined) {
          rows.push(`
            <tr>
              <th style="text-align:left; padding-right:8px">${escapeHTML(k)}</th>
              <td>${escapeHTML(props[k])}</td>
            </tr>`);
        }
      }
      for (const k of Object.keys(props)) {
        if (!keysOrder.includes(k)) {
          rows.push(`
            <tr>
              <th style="text-align:left; padding-right:8px">${escapeHTML(k)}</th>
              <td>${escapeHTML(props[k])}</td>
            </tr>`);
        }
      }
      const html = `<table style="font-size:13px">${rows.join('')}</table>`;
      L.popup().setLatLng(latlng).setContent(html).openOn(map);
    }

    /* ---------- Controls / Events ---------- */
    function wireControls() {
      // смяна на полигонов слой (група)
      document.querySelectorAll('input[name="polyMain"]').forEach(r => {
        r.addEventListener('change', async () => {
          const prevKey = state.activePoly;
          const prevDef = POLY_DEFS[prevKey];
          if (prevDef?.layer && map.hasLayer(prevDef.layer)) map.removeLayer(prevDef.layer);
          if (state.selectedPolygonLayer) {
            try { state.selectedPolygonLayer.setStyle(POLY_DEFS[prevKey].baseStyle); } catch(e){}
          }
          state.selectedPolygonLayer = null;
          state.selectedPolygonFeature = null;

          state.activePolyMain = r.value;

          // показване/скриване на dropdown-а
          const useZones = (state.activePolyMain === 'zones');
          el.zonesLine.classList.toggle('hidden', !useZones);

          // определи реалния ключ
          state.activePoly = useZones ? el.ddZones.value : state.activePolyMain;

          // добави новия слой
          const lay = await ensurePolyLayer(state.activePoly);
          lay.addTo(map);

          // глобален режим на точки
          state.selectedSpeciesKey = null;
          setGlobalExplodedFromActive();
          populateFilterDropdowns(state.explodedPoints);
          state.filteredPoints = [];
          state.pointMarkerLayer.clearLayers();
          el.list.innerHTML = '';
          el.count.textContent = 'Въведете търсене или изберете филтър.';

          // авто-fit и заключване за новия слой
          fitToActivePolyWithSidebar({ lock: true });
        });
      });

      // смяна вътре в dropdown-а (ако групата е активна)
      el.ddZones.addEventListener('change', async () => {
        if (state.activePolyMain !== 'zones') return;

        const prevKey = state.activePoly;
        const prevDef = POLY_DEFS[prevKey];
        if (prevDef?.layer && map.hasLayer(prevDef.layer)) map.removeLayer(prevDef.layer);
        if (state.selectedPolygonLayer) {
          try { state.selectedPolygonLayer.setStyle(POLY_DEFS[prevKey].baseStyle); } catch(e){}
        }
        state.selectedPolygonLayer = null;
        state.selectedPolygonFeature = null;

        state.activePoly = el.ddZones.value;
        const lay = await ensurePolyLayer(state.activePoly);
        lay.addTo(map);

        // нулирай резултати (както при смяна на слой)
        state.selectedSpeciesKey = null;
        setGlobalExplodedFromActive();
        populateFilterDropdowns(state.explodedPoints);
        state.filteredPoints = [];
        state.pointMarkerLayer.clearLayers();
        el.list.innerHTML = '';
        el.count.textContent = 'Въведете търсене или изберете филтър.';

        // авто-fit и заключване за новия под-слой
        fitToActivePolyWithSidebar({ lock: true });
      });

      // смяна на точков слой
      document.querySelectorAll('input[name="points"]').forEach(r => {
        r.addEventListener('change', () => {
          state.activePts = r.value;
          state.selectedSpeciesKey = null; // нулирай при смяна на книга
          refreshFilterVisibility();

          if (state.selectedPolygonFeature) {
            onPolygonClick(state.selectedPolygonFeature, state.selectedPolygonLayer);
          } else {
            setGlobalExplodedFromActive();
            populateFilterDropdowns(state.explodedPoints);
            applyFiltersAndRender();
          }
        });
      });

      // търсене (debounce)
      let t;
      el.search.addEventListener('input', () => {
        clearTimeout(t);
        t = setTimeout(() => { state.selectedSpeciesKey = null; applyFiltersAndRender(); }, 300);
      });

      // филтри
      [el.ddSTATUS, el.ddFAMILY, el.ddTYPE, el.ddORDER, el.cbENDEMIC, el.cbRELICT]
        .forEach(ctrl => {
          ctrl.addEventListener('change', () => { state.selectedSpeciesKey = null; applyFiltersAndRender(); });
        });

      // бутони
      el.btnClearFilters.addEventListener('click', () => {
        el.search.value = '';
        [el.ddSTATUS, el.ddFAMILY, el.ddTYPE, el.ddORDER].forEach(sel => sel.value = '');
        el.cbENDEMIC.checked = false;
        el.cbRELICT.checked  = false;
        state.selectedSpeciesKey = null;
        applyFiltersAndRender();
      });

      el.btnClearSel.addEventListener('click', () => {
        state.selectedSpeciesKey = null;
        clearSelection();
        // re-fit със запазени ограничения
        fitToActivePolyWithSidebar({ refitOnly: true });
      });
    }

    function clearSelection() {
      // върни стил на селектиран полигон, ако има
      if (state.selectedPolygonLayer) {
        try { state.selectedPolygonLayer.setStyle(POLY_DEFS[state.activePoly].baseStyle); } catch(e){}
      }
      state.selectedPolygonLayer = null;
      state.selectedPolygonFeature = null;

      // глобален набор за активния точков слой
      setGlobalExplodedFromActive();
      populateFilterDropdowns(state.explodedPoints);

      state.filteredPoints = [];
      state.pointMarkerLayer.clearLayers();
      for (const m of state.currentMarkers) { m._icon?.classList.remove('highlight'); }
      el.list.innerHTML = '';
      el.count.textContent = 'Въведете търсене или изберете филтър.';
    }

    function refreshFilterVisibility() {
      const isAnimals = state.activePts === 'animals';
      el.rowTypeOrder.classList.toggle('hidden', !isAnimals);
    }

    function escapeHTML(v) {
      if (v===null || v===undefined) return '';
      return String(v)
        .replaceAll('&','&amp;')
        .replaceAll('<','&lt;')
        .replaceAll('>','&gt;')
        .replaceAll('"','&quot;')
        .replaceAll("'",'&#39;');
    }

    /* ---------- Bootstrap ---------- */
    (async function bootstrap(){
      await mapReady;

      const [animals, plants] = await Promise.all([
        fetch(ANIMALS_GEOJSON_URL).then(r => r.json()),
        fetch(PLANTS_FUNGI_GEOJSON_URL).then(r => r.json())
      ]);

      layers.data.animals = animals;
      layers.data.plants  = plants;

      // стартов полигонов слой (land)
      const layer = await ensurePolyLayer(state.activePoly);
      layer.addTo(map);

      setGlobalExplodedFromActive();
      populateFilterDropdowns(state.explodedPoints);

      // авто-fit + заключване след първия moveend
      fitToActivePolyWithSidebar({ lock: true });

      wireControls();
      refreshFilterVisibility();
    })();
  </script>
</body>
</html>
